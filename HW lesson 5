/*Практическое задание по теме «Операторы, фильтрация, сортировка и ограничение»
Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
 */
DROP DATABASE IF EXISTS shop;

CREATE DATABASE shop;

USE shop;

SHOW tables;

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Покупатели';

SELECT * FROM users;

INSERT INTO users (name, birthday_at) VALUES
  ('Геннадий', '1990-10-05'),
  ('Наталья', '1984-11-12'),
  ('Александр', '1985-05-20'),
  ('Сергей', '1988-02-14'),
  ('Иван', '1998-01-12'),
  ('Мария', '1992-08-29');

 UPDATE users
    SET created_at = NULL where id = 5

UPDATE users
    SET updated_at = NULL where id = 6

UPDATE users
    SET created_at = NULL where id = 3

UPDATE users
    SET updated_at = NULL where id = 2

UPDATE users
    SET created_at = NOW() where created_at is NULL;

UPDATE users
    SET updated_at = NOW() WHERE updated_at is NULL;

/*Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы
 * типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10.
 * Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
 */

DESCRIBE users;

ALTER TABLE users
    CHANGE COLUMN `created_at` `created_at` VARCHAR(256) NULL,
    CHANGE COLUMN `updated_at` `updated_at` VARCHAR(256) NULL;

ALTER TABLE users
    CHANGE COLUMN `created_at` `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP,
    CHANGE COLUMN `updated_at` `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP;

 -- как сохранить ранее значения не знаю

 /*В таблице складских запасов storehouses_products в поле value могут встречаться самые
  * разные цифры: 0,
  * если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value.
  * Однако нулевые запасы должны выводиться в конце,  *после всех записей. */

  CREATE TABLE storehouses_products (
  id SERIAL PRIMARY KEY,
  storehouse_id INT UNSIGNED,
  product_id INT UNSIGNED,
  value INT UNSIGNED COMMENT 'Запас товарной позиции на складе',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Запасы на складе';

SELECT * FROM storehouses_products;

INSERT INTO storehouses_products (storehouse_id, product_id, value) VALUES
  (1, 1, 0),
  (2, 2, 2500),
  (3, 3, 0),
  (4, 4, 30),
  (5, 5, 500),
  (6, 6, 1);

 SELECT * FROM storehouses_products ORDER BY value; -- как вставить 0 в конец не знаю

-- по 4-му заданию не смогла до конца посмотреть условие, т.к. сайт GB пока не работает, но примерно решение моё такое:

SELECT * FROM users WHERE birthday_at LIKE '%-05-%'; -- вывод, кто в мае родился

SELECT * FROM users WHERE birthday_at LIKE '%-08-%'; -- в августе

/*Практическое задание теме «Агрегация данных»
1. Подсчитайте средний возраст пользователей в таблице users.
 */
SELECT
  id, name,
  (
    (YEAR(CURRENT_DATE) - YEAR(birthday_at)) -
    (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(birthday_at, '%m%d'))
  ) AS age
FROM users;

SELECT avg(age) FROM (SELECT (YEAR(CURRENT_DATE) - YEAR(birthday_at)) -
    (DATE_FORMAT(CURRENT_DATE, '%m%d') < DATE_FORMAT(birthday_at, '%m%d')) AS age FROM users) AS avg_age;

/*Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели.
 * Следует учесть, что необходимы дни недели текущего года, а не года рождения.
 */ -- не понятно, как это делать. Посмотрела инфо в интернете, не могу разобраться. Сложно.

